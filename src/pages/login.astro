---
import { TokenPayload, getAbsoluteUrl, myJWTVerifyAsync, refreshUserInfo, sha256Base64UrlAsync, states } from 'utils/auth'
import { ConvexHttpClient } from 'convex/browser'
import { ulid } from 'ulidx'

const convexUrl = import.meta.env.PUBLIC_CONVEX_URL
const getConvexClient = () => {
  if (!convexUrl) throw new Error('PUBLIC_CONVEX_URL not set')
  return new ConvexHttpClient(convexUrl)
}

const token = Astro.cookies.get('token')?.value
const expires = Astro.cookies.get('expires')?.value

if (token && expires) {
  try {
    const tokenPayload = TokenPayload.parse(await myJWTVerifyAsync(token))
    const convex = getConvexClient()
    const { api } = await import('../../convex/_generated/api')
    const user = await convex.query(api.users.getByVisibleId, { visibleId: tokenPayload.id })

    if (user?.refreshToken) {
      if (new Date(expires) < new Date()) {
        const [userInfo] = await refreshUserInfo({
          grant_type: 'refresh_token',
          client_id: import.meta.env.OAUTH_CLIENT_ID,
          redirect_uri: getAbsoluteUrl(Astro.url, '/callback'),
          code: user.refreshToken,
        }, Astro.cookies, user.role)
        
        if (!userInfo) return new Response(null, { status: 403 })
        
        const { id: _id, ...data } = userInfo
        await convex.mutation(api.users.update, { id: user._id, ...data })
      }

      return Astro.redirect(`/`)
    }
  } catch {
    // Invalid token, retrieve new one
  }
}

// ulid ~ 01F7DKCVCVDZN1Z5Q4FWANHHCC 
const codeVerifier = ulid() + ulid() + ulid()
const codeChallenge = await sha256Base64UrlAsync(codeVerifier)

const state = ulid()

states.set(state, { codeChallenge, codeVerifier })

const params = new URLSearchParams({
  client_id: import.meta.env.OAUTH_CLIENT_ID,
  redirect_uri: getAbsoluteUrl(Astro.url, '/callback'),
  response_type: 'code',
  scope: 'openid profile',
  state,
  code_challenge: codeChallenge,
  code_challenge_method: 'S256'
})
return Astro.redirect(`https://oauth.chess.com/authorize?${params}`)

---
